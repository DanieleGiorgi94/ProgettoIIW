#include "../header.h"

static int select_available_port(struct available_ports *);

void *create_connection(void *arg) {
    struct service_thread *ptd = (struct service_thread *) arg;

    int sockfd = ptd->sockfd;
    struct sockaddr_in servaddr = ptd->servaddr;
    char *no_connections = ptd->no_connections;
    char *path = ptd->path;
    u64 client_isn = ptd->isn;
    struct available_ports *ports = ptd->ports;

    int new_sockfd;
    int new_port_index;
    int new_port_number;

    srand(time(NULL) + getpid());

    u32 slen = sizeof(struct sockaddr);
    request_t *req = (request_t *) dynamic_allocation(sizeof(request_t));

    u64 server_isn = rand() % 100;
    new_port_index = select_available_port(ports);
    new_port_number = PORT + new_port_index;
    printf("The first empty port_number is: %d\n", new_port_number);

    if (new_port_index == -1) {
        printf("Connessioni finite\n");
        return NULL;
    }

    req->initial_n_seq = server_isn;
    req->SYN = 1;
    req->ACK = client_isn + 1;
    req->FIN = 0;
    req->port_number = new_port_number;

    if (sendto(sockfd, (void *) req, sizeof(request_t), 0,
            (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
        free_allocation(req);
        perror("Errore in sendto: invio del pacchetto twh_request_t");
        exit(EXIT_FAILURE);
    }
    printf("Sent SYN-ACK %d %d, server_isn: %lu\n", req->SYN, req->ACK,
        req->initial_n_seq);

    while (recvfrom(sockfd, (void *) req, sizeof(request_t),
            MSG_DONTWAIT, (struct sockaddr *) &servaddr, &slen) < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("recvfrom() failed");
            free(req);
            return NULL;
        }
    }
    printf("Received ACK, %d %d %d\n", req->ACK, (char) req->initial_n_seq,
        (char) server_isn + 1);

    //nuova socket
    if (req->SYN == 0 && (req->ACK == (char) server_isn + 1 ||
                                                        req->FIN > 0)) {
        if ((new_sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
            perror("socket() failed");
            exit(EXIT_FAILURE);
        }
        
        memset((void *) &servaddr, 0, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
        servaddr.sin_port = htons(new_port_number);
        if (bind(new_sockfd, (struct sockaddr *) &servaddr,
                                                    sizeof(servaddr)) < 0) {
            perror("errore in bind");
            exit(EXIT_FAILURE);
        }
        ports->available[new_port_index] = 1;
    } else {
        printf("ACK not correctly received.\n");
        *no_connections -= 1;
        return NULL;
    }
    /******* 3Way Handshake completed ********/

    free(req);
    req = (request_t *) dynamic_allocation(sizeof(request_t));
    req->SYN = 1;
    if (sendto(new_sockfd, (void *) req, sizeof(request_t), 0,
            (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
        free_allocation(req);
        perror("Errore in sendto: invio del pacchetto twh_request_t");
        exit(EXIT_FAILURE);
    }

    printf("SYN new socket\n");

    LISTEN:
    while (recvfrom(new_sockfd, (void *) req, sizeof(request_t), MSG_DONTWAIT,
                    (struct sockaddr *) &servaddr, &slen) < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("recvfrom() failed");
            free(req);
            return NULL;
        }
    }
    
    if (req->type == GET_REQ)
        get_command_handler(sockfd, servaddr, req->payload, path);
    else if (req->type == PUT_REQ)
        put_command_handler(sockfd, servaddr, req->payload, path);
    else if (req->type == LIST_REQ)
        list_command_handler(sockfd, servaddr, path);
    else if (req->type == EXIT_REQ)
        exit_command_handler(sockfd, 1, ptd->no_connections, servaddr);
    
    goto LISTEN;
}

static int select_available_port(struct available_ports *ports) {
    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        if (ports->available[i] == 0)
            return i + 1;
    }
    return -1;
}
